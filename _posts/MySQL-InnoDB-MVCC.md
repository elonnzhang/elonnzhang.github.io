![](assets/img/Pasted%20image%2020250812160133.png)

![](assets/img/Pasted%20image%2020250812160211.png)

**MVCC（多版本并发控制）** 是一种数据库并发控制机制，用于管理多个事务并发操作时，确保事务的 **隔离性** 和 **一致性**。在 **MySQL InnoDB** 存储引擎中，MVCC 是实现 **事务隔离** 和 **高并发** 数据访问的关键技术之一。MVCC 允许多个事务在 **不冲突** 的情况下并发执行，同时保证每个事务的 **数据一致性**。

  

### **1. MVCC 的工作原理**

  

MVCC 通过 **维护数据的多个版本** 来实现高并发控制，而不是像传统的锁机制那样阻塞事务，MVCC 通过给每个事务分配 **快照** 来实现并发读写。

  

#### **1.1. 事务的隔离性**

  

在 MVCC 中，每个事务都有一个 **独立的视图（Read View）**，它表示当前事务看到的数据版本。这确保了不同的事务可以并发执行，但又不互相影响，避免了 **脏读**、**不可重复读** 和 **幻读** 问题。

  

#### **1.2. 如何维护多个版本的记录**

- **InnoDB** 会为每个数据行维护多个版本，这些版本用于支持多个事务并发执行。每个修改操作会创建数据的一个新的版本。
    
- 每个版本的数据行都会包含 **事务 ID** 和 **回滚标识（Undo Log）**，这些信息有助于数据库确定该数据是否对当前事务可见。
    

  

例如，在更新操作时，**更新前的版本** 保留在 **Undo Log** 中，而新的版本会出现在 **数据表中**。

---

### **2. Read View 在 MVCC 中如何工作**

  

**Read View** 是 MySQL 在 **MVCC** 中实现隔离性的关键概念。当一个事务需要读取数据时，数据库会为该事务创建一个 **Read View**，并根据该视图决定事务能够看到哪些数据。

  

#### **2.1. 创建 Read View**

  

每个事务在执行时，都会根据其开始时的 **事务 ID** 创建一个 **Read View**，Read View 是当前事务的 “快照”。在事务执行过程中，Read View 会记录以下信息：

1. **当前事务的 ID**：它是事务的唯一标识符。
    
2. **所有正在执行的事务的事务 ID**：这些事务在当前事务的 **视图** 中是不可见的。
    
3. **已提交事务的事务 ID**：当前事务可以看到这些事务的修改。
    
4. **最早的事务 ID**：表示数据库中最早可见的事务。
    

  

在 **Read View** 中，事务 ID 会标记为以下几类：

- **小于当前事务的事务 ID**：表示事务在创建 Read View 时已经提交，当前事务可以看到这些事务的修改。
    
- **大于当前事务的事务 ID**：表示事务尚未提交，当前事务看不到这些事务的修改。
    
- **等于当前事务的事务 ID**：表示当前事务自身所做的修改。
    

  

#### **2.2. 使用 Read View 进行数据访问**

  

当事务执行查询时，**Read View** 会判断每一行数据是否符合当前事务的视图条件。具体来说：

- 如果行的 **事务 ID 小于当前事务的事务 ID**，表示该行数据属于 **已提交事务**，当前事务可以看到这行数据。
    
- 如果行的 **事务 ID 大于当前事务的事务 ID**，表示该行数据属于 **未提交事务**，当前事务无法看到这行数据。
    
- 如果行的 **事务 ID 等于当前事务的事务 ID**，则该行数据是当前事务的修改，可以读取。
    

  

通过这种方式，MVCC 确保了每个事务在执行时，读取的数据是 **一致的**，并且 **隔离的**。

  

#### **2.3. 可重复读**

  

在 **REPEATABLE READ** 隔离级别下，使用 Read View 时，事务会在开始时生成 **一个固定的快照**，所有后续的查询都只会读取到当前快照下的数据。即使其他事务对数据进行了修改或提交，当前事务仍然会看到在事务开始时的 **数据视图**，避免了 **不可重复读** 的问题。

---

### **3. 如果没有 MVCC 会怎样？**

  

如果没有 MVCC，MySQL 就无法实现 **高效的并发控制**，特别是在 **事务隔离** 和 **数据一致性** 方面会受到很大的限制。没有 MVCC，MySQL 只能依赖 **锁机制** 来处理并发事务，但这样会导致以下问题：

  

#### **3.1. 锁竞争和性能瓶颈**

- 没有 MVCC 时，事务必须通过 **行级锁** 或 **表级锁** 来保证数据的隔离性，这会引入 **锁竞争**。
    
- 当一个事务在修改数据时，其他事务必须等待该事务释放锁，这会导致性能下降，特别是在高并发情况下。
    

  

#### **3.2. 事务的隔离性问题**

- 如果没有 MVCC，数据库中的事务在读数据时无法获取快照，所有事务的操作都必须互相阻塞，无法实现 **并发读取**。
    
- 在 **高并发环境** 下，这会导致 **长时间的等待** 和 **性能下降**，甚至可能出现 **死锁** 问题。
    

  

#### **3.3. 脏读、不可重复读、幻读**

- 在没有 MVCC 的情况下，事务的读操作可能会读到其他事务尚未提交的数据，这会导致 **脏读**。
    
- 如果没有 MVCC，同一事务中的多个读操作可能会看到不同的数据版本，从而导致 **不可重复读**。
    
- 没有 MVCC，多个事务并发执行时，事务可能会看到不一致的数据范围，导致 **幻读**。
    

---

### **4. 总结**

- **MVCC（多版本并发控制）** 通过给每个事务提供一个 **独立的视图（Read View）** 来确保事务隔离性，并通过版本控制来避免锁竞争，从而提高数据库的并发能力。
    
- **Read View** 是每个事务的 **快照**，它确定了当前事务可以看到哪些数据版本，确保同一事务的多次查询得到一致的结果。
    
- 如果没有 MVCC，MySQL 将依赖传统的锁机制来控制并发，但这会导致更大的锁竞争、性能瓶颈和更低的并发性。事务隔离性问题（如脏读、不可重复读、幻读）也会更难解决。
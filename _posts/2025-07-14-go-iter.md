---
layout: post
title: Go 1.23 iter 学习
date: 2025-07-14
categories: Golang
---


(https://mp.weixin.qq.com/s?biz=MzA4ODg0NDkzOA==&mid=2247510020&idx=1&sn=c4daaaf3e895bf17a76e2481a74bf243&chksm=91a791e540e5ee433099f24654eaf06126750dd2392d660bf9144cbf33582e4e0022a6f060f9#rd)



![[iter1.png]]

![[iter2.png]]

也就是说只有符合上述函数签名的函数类型才是可以被for range支持的iterator。即所谓自定义iterator，本质上就是一个**接受一个函数类型参数的函数(如上图中红框①)**，按惯例，这个函数类型的参数**被命名为yield(见红框②)**。从Backward函数的返回值(一个iterator)的实现来看，_**当yield函数返回false时，迭代结束；否则迭代继续进行，直到集合类型(如slice)中所有元素都被遍历完**_。

其实，for range+自定义iterator可以看成是Go提供的又一个“语法糖”，它是**通过Go编译器在编译阶段的代码转换**来实现的。下面我们还基于Backward那个例子来看看这个转换过程：


![[iter3.png]]
